/*
 * Thalex API Description
 *
 * Talex API documentation
 *
 * The version of the OpenAPI document: 2.49.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`rest_private_slash_amend`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashAmendParams {
    pub rest_private_amend_request: Option<models::RestPrivateAmendRequest>
}

/// struct for passing parameters to the method [`rest_private_slash_buy`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashBuyParams {
    pub insert_request: Option<models::InsertRequest>
}

/// struct for passing parameters to the method [`rest_private_slash_cancel`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashCancelParams {
    pub rest_private_cancel_request: Option<models::RestPrivateCancelRequest>
}

/// struct for passing parameters to the method [`rest_private_slash_cancel_all`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashCancelAllParams {
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`rest_private_slash_insert`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashInsertParams {
    pub rest_private_insert_request: Option<models::RestPrivateInsertRequest>
}

/// struct for passing parameters to the method [`rest_private_slash_sell`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashSellParams {
    pub insert_request: Option<models::InsertRequest>
}


/// struct for typed errors of method [`rest_private_slash_amend`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashAmendError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_buy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashBuyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_cancel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashCancelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_cancel_all`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashCancelAllError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_insert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashInsertError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_sell`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashSellError {
    UnknownValue(serde_json::Value),
}


/// Exchange: `https://thalex.com/api/v2/private/amend`  Testnet: `https://testnet.thalex.com/api/v2/private/amend`  Note that `amount` designates the new \"original\" amount, i.e. the amend is volume-safe. If the specified amount is lower than the already executed amount, the order is deleted.  If the price of the order is the same as the previous price, and the amount is less than the previous amount, book priority is preserved.  If the `amount` is amended to a value at or below the executed amount, the order is cancelled. 
pub fn rest_private_slash_amend(configuration: &configuration::Configuration, params: RestPrivateSlashAmendParams) -> Result<models::RestPrivateAmend200Response, Error<RestPrivateSlashAmendError>> {

    let uri_str = format!("{}/private/amend", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.rest_private_amend_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateAmend200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateAmend200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashAmendError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/buy`  Testnet: `https://testnet.thalex.com/api/v2/private/buy`  Insert buy order
pub fn rest_private_slash_buy(configuration: &configuration::Configuration, params: RestPrivateSlashBuyParams) -> Result<models::RestPrivateInsert200Response, Error<RestPrivateSlashBuyError>> {

    let uri_str = format!("{}/private/buy", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.insert_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateInsert200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateInsert200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashBuyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/cancel`  Testnet: `https://testnet.thalex.com/api/v2/private/cancel`  Cancel order
pub fn rest_private_slash_cancel(configuration: &configuration::Configuration, params: RestPrivateSlashCancelParams) -> Result<models::RestPrivateCancel200Response, Error<RestPrivateSlashCancelError>> {

    let uri_str = format!("{}/private/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.rest_private_cancel_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateCancel200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateCancel200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashCancelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/cancel_all`  Testnet: `https://testnet.thalex.com/api/v2/private/cancel_all`  Cancels all orders for the account. This may *not* match new orders in flight (see `private/cancel_session`). 
pub fn rest_private_slash_cancel_all(configuration: &configuration::Configuration, params: RestPrivateSlashCancelAllParams) -> Result<models::RestPrivateCancelAll200Response, Error<RestPrivateSlashCancelAllError>> {

    let uri_str = format!("{}/private/cancel_all", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateCancelAll200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateCancelAll200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashCancelAllError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/insert`  Testnet: `https://testnet.thalex.com/api/v2/private/insert`  Insert an order
pub fn rest_private_slash_insert(configuration: &configuration::Configuration, params: RestPrivateSlashInsertParams) -> Result<models::RestPrivateInsert200Response, Error<RestPrivateSlashInsertError>> {

    let uri_str = format!("{}/private/insert", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.rest_private_insert_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateInsert200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateInsert200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashInsertError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/sell`  Testnet: `https://testnet.thalex.com/api/v2/private/sell`  Insert sell order
pub fn rest_private_slash_sell(configuration: &configuration::Configuration, params: RestPrivateSlashSellParams) -> Result<models::RestPrivateSell200Response, Error<RestPrivateSlashSellError>> {

    let uri_str = format!("{}/private/sell", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.insert_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateSell200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateSell200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashSellError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

