/*
 * Thalex API Description
 *
 * Talex API documentation
 *
 * The version of the OpenAPI document: 2.49.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`rest_private_slash_verify_internal_transfer`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashVerifyInternalTransferParams {
    pub rest_private_verify_internal_transfer_request: Option<models::RestPrivateVerifyInternalTransferRequest>
}

/// struct for passing parameters to the method [`rest_private_slash_verify_withdrawal`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashVerifyWithdrawalParams {
    pub asset_name: String,
    pub amount: f64,
    pub target_address: String
}


/// struct for typed errors of method [`rest_private_slash_btc_deposit_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashBtcDepositAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_crypto_deposits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashCryptoDepositsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_crypto_withdrawals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashCryptoWithdrawalsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_eth_deposit_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashEthDepositAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_verify_internal_transfer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashVerifyInternalTransferError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_verify_withdrawal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashVerifyWithdrawalError {
    UnknownValue(serde_json::Value),
}


/// Exchange: `https://thalex.com/api/v2/private/btc_deposit_address`  Testnet: `https://testnet.thalex.com/api/v2/private/btc_deposit_address`  Get Bitcoin deposit address
pub fn rest_private_slash_btc_deposit_address(configuration: &configuration::Configuration) -> Result<models::RestPrivateBtcDepositAddress200Response, Error<RestPrivateSlashBtcDepositAddressError>> {

    let uri_str = format!("{}/private/btc_deposit_address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateBtcDepositAddress200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateBtcDepositAddress200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashBtcDepositAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/crypto_deposits`  Testnet: `https://testnet.thalex.com/api/v2/private/crypto_deposits`  Pending and confirmed deposits for the selected account.
pub fn rest_private_slash_crypto_deposits(configuration: &configuration::Configuration) -> Result<models::RestPrivateCryptoDeposits200Response, Error<RestPrivateSlashCryptoDepositsError>> {

    let uri_str = format!("{}/private/crypto_deposits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateCryptoDeposits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateCryptoDeposits200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashCryptoDepositsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/crypto_withdrawals`  Testnet: `https://testnet.thalex.com/api/v2/private/crypto_withdrawals`  List of withdrawals from the selected account. Includes all withdrawals: pending, executed, rejected etc. 
pub fn rest_private_slash_crypto_withdrawals(configuration: &configuration::Configuration) -> Result<models::RestPrivateCryptoWithdrawals200Response, Error<RestPrivateSlashCryptoWithdrawalsError>> {

    let uri_str = format!("{}/private/crypto_withdrawals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateCryptoWithdrawals200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateCryptoWithdrawals200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashCryptoWithdrawalsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/eth_deposit_address`  Testnet: `https://testnet.thalex.com/api/v2/private/eth_deposit_address`  Get Ethereum deposit address
pub fn rest_private_slash_eth_deposit_address(configuration: &configuration::Configuration) -> Result<models::RestPrivateEthDepositAddress200Response, Error<RestPrivateSlashEthDepositAddressError>> {

    let uri_str = format!("{}/private/eth_deposit_address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateEthDepositAddress200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateEthDepositAddress200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashEthDepositAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/verify_internal_transfer`  Testnet: `https://testnet.thalex.com/api/v2/private/verify_internal_transfer`  Verify if internal transfer of assets and/or positions from source (currently selected) to destination account is possible. Does not perform the transfer itself.  Transfers are subject to margin checks.  A transfer cannot result in an account breaching margin requirements. This applies to both source and destination accounts.  If either of the accounts is already in margin breach state, the transfer is only allowed if it results in an increase of available margin on that account. The other account must not breach margin requirement as a result of the transfer. This allows transferring assets and/or positions from an account with enough extra margin to an account that was margin called.  Each transfer can contain multiple asset and position transfers. It is checked for margin requirements as a single transaction. It is possible to specify negative amounts for transferred assets and positions, which results in a reverse direction of transfer (i.e. from destination account to the source one). This allows performing asset/position exchange operations, and is helpful when a leg of such operation alone would result in a margin requirements breach. 
pub fn rest_private_slash_verify_internal_transfer(configuration: &configuration::Configuration, params: RestPrivateSlashVerifyInternalTransferParams) -> Result<models::RestPrivateVerifyInternalTransfer200Response, Error<RestPrivateSlashVerifyInternalTransferError>> {

    let uri_str = format!("{}/private/verify_internal_transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.rest_private_verify_internal_transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateVerifyInternalTransfer200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateVerifyInternalTransfer200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashVerifyInternalTransferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/verify_withdrawal`  Testnet: `https://testnet.thalex.com/api/v2/private/verify_withdrawal`  This method is subject to withdrawal permissions.
pub fn rest_private_slash_verify_withdrawal(configuration: &configuration::Configuration, params: RestPrivateSlashVerifyWithdrawalParams) -> Result<models::RestPrivateVerifyWithdrawal200Response, Error<RestPrivateSlashVerifyWithdrawalError>> {

    let uri_str = format!("{}/private/verify_withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("asset_name", &params.asset_name.to_string())]);
    req_builder = req_builder.query(&[("amount", &params.amount.to_string())]);
    req_builder = req_builder.query(&[("target_address", &params.target_address.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateVerifyWithdrawal200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateVerifyWithdrawal200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashVerifyWithdrawalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

