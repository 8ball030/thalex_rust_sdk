/*
 * Thalex API Description
 *
 * Talex API documentation
 *
 * The version of the OpenAPI document: 2.49.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`rest_public_slash_all_instruments`]
#[derive(Clone, Debug)]
pub struct RestPublicSlashAllInstrumentsParams {
    pub time_low: Option<f64>,
    pub time_high: Option<f64>
}

/// struct for passing parameters to the method [`rest_public_slash_book`]
#[derive(Clone, Debug)]
pub struct RestPublicSlashBookParams {
    pub instrument_name: String
}

/// struct for passing parameters to the method [`rest_public_slash_index`]
#[derive(Clone, Debug)]
pub struct RestPublicSlashIndexParams {
    pub underlying: String
}

/// struct for passing parameters to the method [`rest_public_slash_instrument`]
#[derive(Clone, Debug)]
pub struct RestPublicSlashInstrumentParams {
    pub instrument_name: String
}

/// struct for passing parameters to the method [`rest_public_slash_ticker`]
#[derive(Clone, Debug)]
pub struct RestPublicSlashTickerParams {
    pub instrument_name: String
}


/// struct for typed errors of method [`rest_public_slash_all_instruments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPublicSlashAllInstrumentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_public_slash_book`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPublicSlashBookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_public_slash_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPublicSlashIndexError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_public_slash_instrument`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPublicSlashInstrumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_public_slash_instruments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPublicSlashInstrumentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_public_slash_ticker`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPublicSlashTickerError {
    UnknownValue(serde_json::Value),
}


/// Exchange: `https://thalex.com/api/v2/public/all_instruments`  Testnet: `https://testnet.thalex.com/api/v2/public/all_instruments`  Retrieves the list of all instruments that were active in the specified time interval.  Note that the time interval cannot be larger than 3 days.  You can also use `public/instrument` call to retrieve information about a specific instrument. 
pub fn rest_public_slash_all_instruments(configuration: &configuration::Configuration, params: RestPublicSlashAllInstrumentsParams) -> Result<models::RestPublicAllInstruments200Response, Error<RestPublicSlashAllInstrumentsError>> {

    let uri_str = format!("{}/public/all_instruments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.time_low {
        req_builder = req_builder.query(&[("time_low", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_high {
        req_builder = req_builder.query(&[("time_high", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPublicAllInstruments200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPublicAllInstruments200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPublicSlashAllInstrumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/public/book`  Testnet: `https://testnet.thalex.com/api/v2/public/book`  Retrieves aggregated price depth for a single instrument, with a maximum of 5 levels. Please do *not* use this to poll for data -- a websocket subscription is more flexible and more useful. 
pub fn rest_public_slash_book(configuration: &configuration::Configuration, params: RestPublicSlashBookParams) -> Result<models::RestPublicBook200Response, Error<RestPublicSlashBookError>> {

    let uri_str = format!("{}/public/book", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instrument_name", &params.instrument_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPublicBook200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPublicBook200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPublicSlashBookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/public/index`  Testnet: `https://testnet.thalex.com/api/v2/public/index`  Retrieves the index price for a single underlying. If needed repeatedly, please use the `price_index.<underlying>` websocket subscription. 
pub fn rest_public_slash_index(configuration: &configuration::Configuration, params: RestPublicSlashIndexParams) -> Result<models::RestPublicIndex200Response, Error<RestPublicSlashIndexError>> {

    let uri_str = format!("{}/public/index", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("underlying", &params.underlying.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPublicIndex200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPublicIndex200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPublicSlashIndexError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/public/instrument`  Testnet: `https://testnet.thalex.com/api/v2/public/instrument`  Retrieves a singe instrument.  Unlike `public/all_instruments`, this API endpoint allows retrieving information about instruments that have expired long time ago. 
pub fn rest_public_slash_instrument(configuration: &configuration::Configuration, params: RestPublicSlashInstrumentParams) -> Result<models::RestPublicInstrument200Response, Error<RestPublicSlashInstrumentError>> {

    let uri_str = format!("{}/public/instrument", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instrument_name", &params.instrument_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPublicInstrument200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPublicInstrument200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPublicSlashInstrumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/public/instruments`  Testnet: `https://testnet.thalex.com/api/v2/public/instruments`  Retrieves the list of currently active instruments. 
pub fn rest_public_slash_instruments(configuration: &configuration::Configuration) -> Result<models::RestPublicInstruments200Response, Error<RestPublicSlashInstrumentsError>> {

    let uri_str = format!("{}/public/instruments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPublicInstruments200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPublicInstruments200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPublicSlashInstrumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/public/ticker`  Testnet: `https://testnet.thalex.com/api/v2/public/ticker`  Retrieves a single ticker for a single instrument. Please do *not* use this to repeatedly poll for data -- a websocket subscription is much more useful. 
pub fn rest_public_slash_ticker(configuration: &configuration::Configuration, params: RestPublicSlashTickerParams) -> Result<models::RestPublicTicker200Response, Error<RestPublicSlashTickerError>> {

    let uri_str = format!("{}/public/ticker", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instrument_name", &params.instrument_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPublicTicker200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPublicTicker200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPublicSlashTickerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

