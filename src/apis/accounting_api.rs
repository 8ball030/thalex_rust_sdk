/*
 * Thalex API Description
 *
 * Talex API documentation
 *
 * The version of the OpenAPI document: 2.49.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`rest_private_slash_daily_mark_history`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashDailyMarkHistoryParams {
    pub limit: Option<i32>,
    pub time_low: Option<f64>,
    pub time_high: Option<f64>,
    pub bookmark: Option<String>
}

/// struct for passing parameters to the method [`rest_private_slash_order_history`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashOrderHistoryParams {
    pub limit: Option<i32>,
    pub time_low: Option<f64>,
    pub time_high: Option<f64>,
    pub bookmark: Option<String>,
    pub sort: Option<String>,
    pub instrument_names: Option<String>,
    pub bot_ids: Option<String>
}

/// struct for passing parameters to the method [`rest_private_slash_required_margin_for_order`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashRequiredMarginForOrderParams {
    pub price: f64,
    pub amount: f64,
    pub instrument_name: Option<String>,
    pub legs: Option<Vec<models::RestPrivateRequiredMarginForOrderLegsParameterInner>>
}

/// struct for passing parameters to the method [`rest_private_slash_rfq_history`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashRfqHistoryParams {
    pub limit: Option<i32>,
    pub time_low: Option<f64>,
    pub time_high: Option<f64>,
    pub bookmark: Option<String>
}

/// struct for passing parameters to the method [`rest_private_slash_trade_history`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashTradeHistoryParams {
    pub limit: Option<i32>,
    pub time_low: Option<f64>,
    pub time_high: Option<f64>,
    pub bookmark: Option<String>,
    pub sort: Option<String>,
    pub instrument_names: Option<String>,
    pub bot_ids: Option<String>
}

/// struct for passing parameters to the method [`rest_private_slash_transaction_history`]
#[derive(Clone, Debug)]
pub struct RestPrivateSlashTransactionHistoryParams {
    pub limit: Option<i32>,
    pub time_low: Option<f64>,
    pub time_high: Option<f64>,
    pub bookmark: Option<String>
}


/// struct for typed errors of method [`rest_private_slash_account_breakdown`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashAccountBreakdownError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_account_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashAccountSummaryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_daily_mark_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashDailyMarkHistoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_open_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashOpenOrdersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_order_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashOrderHistoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_portfolio`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashPortfolioError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_required_margin_breakdown`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashRequiredMarginBreakdownError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_required_margin_for_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashRequiredMarginForOrderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_rfq_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashRfqHistoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_trade_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashTradeHistoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rest_private_slash_transaction_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestPrivateSlashTransactionHistoryError {
    UnknownValue(serde_json::Value),
}


/// Exchange: `https://thalex.com/api/v2/private/account_breakdown`  Testnet: `https://testnet.thalex.com/api/v2/private/account_breakdown`  Get account breakdown
pub fn rest_private_slash_account_breakdown(configuration: &configuration::Configuration) -> Result<models::RestPrivateAccountBreakdown200Response, Error<RestPrivateSlashAccountBreakdownError>> {

    let uri_str = format!("{}/private/account_breakdown", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateAccountBreakdown200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateAccountBreakdown200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashAccountBreakdownError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/account_summary`  Testnet: `https://testnet.thalex.com/api/v2/private/account_summary`  Get account summary
pub fn rest_private_slash_account_summary(configuration: &configuration::Configuration) -> Result<models::RestPrivateAccountSummary200Response, Error<RestPrivateSlashAccountSummaryError>> {

    let uri_str = format!("{}/private/account_summary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateAccountSummary200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateAccountSummary200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashAccountSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/daily_mark_history`  Testnet: `https://testnet.thalex.com/api/v2/private/daily_mark_history`  For instruments that are subject to futures-style settlement we perform daily settlement at the mark price. The settlement procedure realizes the positional and perpetual funding profits/losses accumulated during the session, and resets the start price of the position to the mark price.  This API endpoint returns a historical log of settled profits/losses (daily marks). 
pub fn rest_private_slash_daily_mark_history(configuration: &configuration::Configuration, params: RestPrivateSlashDailyMarkHistoryParams) -> Result<models::RestPrivateDailyMarkHistory200Response, Error<RestPrivateSlashDailyMarkHistoryError>> {

    let uri_str = format!("{}/private/daily_mark_history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_low {
        req_builder = req_builder.query(&[("time_low", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_high {
        req_builder = req_builder.query(&[("time_high", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.bookmark {
        req_builder = req_builder.query(&[("bookmark", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateDailyMarkHistory200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateDailyMarkHistory200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashDailyMarkHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/open_orders`  Testnet: `https://testnet.thalex.com/api/v2/private/open_orders`  Get open orders
pub fn rest_private_slash_open_orders(configuration: &configuration::Configuration) -> Result<models::RestPrivateOpenOrders200Response, Error<RestPrivateSlashOpenOrdersError>> {

    let uri_str = format!("{}/private/open_orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateOpenOrders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateOpenOrders200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashOpenOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/order_history`  Testnet: `https://testnet.thalex.com/api/v2/private/order_history`  Retrieves a list of past orders (i.e. orders that are not active anymore) since the last 90 days. Allows sorting and filtering by instrument name.  Unfilled market maker orders are not included.  Orders are like order status updates, without the `remaining_amount` field (always 0), and with a `close_time` timestamp. Note that, for technical reasons, the 'fills' field in the order is limited to a length of 8. For a full list of trades, refer to trade history.  Note that it is not real-time, data might appear with a slight delay. 
pub fn rest_private_slash_order_history(configuration: &configuration::Configuration, params: RestPrivateSlashOrderHistoryParams) -> Result<models::RestPrivateOrderHistory200Response, Error<RestPrivateSlashOrderHistoryError>> {

    let uri_str = format!("{}/private/order_history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_low {
        req_builder = req_builder.query(&[("time_low", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_high {
        req_builder = req_builder.query(&[("time_high", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.bookmark {
        req_builder = req_builder.query(&[("bookmark", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.instrument_names {
        req_builder = req_builder.query(&[("instrument_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.bot_ids {
        req_builder = req_builder.query(&[("bot_ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateOrderHistory200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateOrderHistory200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashOrderHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/portfolio`  Testnet: `https://testnet.thalex.com/api/v2/private/portfolio`  Get account portfolio
pub fn rest_private_slash_portfolio(configuration: &configuration::Configuration) -> Result<models::RestPrivatePortfolio200Response, Error<RestPrivateSlashPortfolioError>> {

    let uri_str = format!("{}/private/portfolio", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivatePortfolio200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivatePortfolio200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashPortfolioError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/required_margin_breakdown`  Testnet: `https://testnet.thalex.com/api/v2/private/required_margin_breakdown`  Get margin breakdown
pub fn rest_private_slash_required_margin_breakdown(configuration: &configuration::Configuration) -> Result<models::RestPrivateRequiredMarginBreakdown200Response, Error<RestPrivateSlashRequiredMarginBreakdownError>> {

    let uri_str = format!("{}/private/required_margin_breakdown", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateRequiredMarginBreakdown200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateRequiredMarginBreakdown200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashRequiredMarginBreakdownError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/required_margin_for_order`  Testnet: `https://testnet.thalex.com/api/v2/private/required_margin_for_order`  This method returns a lightweight breakdown of the account as it is, and also as if a hypothetical order of a given price and amount would be inserted on either side of the book.
pub fn rest_private_slash_required_margin_for_order(configuration: &configuration::Configuration, params: RestPrivateSlashRequiredMarginForOrderParams) -> Result<models::RestPrivateRequiredMarginForOrder200Response, Error<RestPrivateSlashRequiredMarginForOrderError>> {

    let uri_str = format!("{}/private/required_margin_for_order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.instrument_name {
        req_builder = req_builder.query(&[("instrument_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.legs {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("legs".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("legs", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    req_builder = req_builder.query(&[("price", &params.price.to_string())]);
    req_builder = req_builder.query(&[("amount", &params.amount.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateRequiredMarginForOrder200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateRequiredMarginForOrder200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashRequiredMarginForOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/rfq_history`  Testnet: `https://testnet.thalex.com/api/v2/private/rfq_history`  Retrieves a list of past RFQs for the account. Open RFQs are not incuded. 
pub fn rest_private_slash_rfq_history(configuration: &configuration::Configuration, params: RestPrivateSlashRfqHistoryParams) -> Result<models::RestPrivateRfqHistory200Response, Error<RestPrivateSlashRfqHistoryError>> {

    let uri_str = format!("{}/private/rfq_history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_low {
        req_builder = req_builder.query(&[("time_low", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_high {
        req_builder = req_builder.query(&[("time_high", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.bookmark {
        req_builder = req_builder.query(&[("bookmark", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateRfqHistory200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateRfqHistory200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashRfqHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/trade_history`  Testnet: `https://testnet.thalex.com/api/v2/private/trade_history`  Retrieves trades for the last 90 days. Allows sorting and filtering by instrument name. Note that it is not real-time, trades might appear with a slight delay.
pub fn rest_private_slash_trade_history(configuration: &configuration::Configuration, params: RestPrivateSlashTradeHistoryParams) -> Result<models::RestPrivateTradeHistory200Response, Error<RestPrivateSlashTradeHistoryError>> {

    let uri_str = format!("{}/private/trade_history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_low {
        req_builder = req_builder.query(&[("time_low", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_high {
        req_builder = req_builder.query(&[("time_high", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.bookmark {
        req_builder = req_builder.query(&[("bookmark", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.instrument_names {
        req_builder = req_builder.query(&[("instrument_names", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.bot_ids {
        req_builder = req_builder.query(&[("bot_ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateTradeHistory200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateTradeHistory200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashTradeHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange: `https://thalex.com/api/v2/private/transaction_history`  Testnet: `https://testnet.thalex.com/api/v2/private/transaction_history`  Get transaction history
pub fn rest_private_slash_transaction_history(configuration: &configuration::Configuration, params: RestPrivateSlashTransactionHistoryParams) -> Result<models::RestPrivateTransactionHistory200Response, Error<RestPrivateSlashTransactionHistoryError>> {

    let uri_str = format!("{}/private/transaction_history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_low {
        req_builder = req_builder.query(&[("time_low", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time_high {
        req_builder = req_builder.query(&[("time_high", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.bookmark {
        req_builder = req_builder.query(&[("bookmark", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RestPrivateTransactionHistory200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RestPrivateTransactionHistory200Response`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<RestPrivateSlashTransactionHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

